{{-
# Terminal identifiers
term_ids = assign_ids(table.terminals)
# Nonterminal identifiers
nonterm_ids = assign_ids(table.nonterminals)

# Deduplicate action states
dedup_states = lr_deduplicate_actions_rows(table)
uniq_states = array.sort(array.uniq(array.map(dedup_states, "value")), "id")
# Row start indices
action_row_starts = {}
# Reduce actions
reduce_actions = array.filter(lr_all_actions(table), @is_reduce)
reduce_action_ids = assign_ids(reduce_actions)
-}}
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;

public class Parser
{
    private readonly Lexer lexer;
    private readonly Stack<int> stateStack = new();
    private readonly Stack<ParseTree> symbolStack = new();

    public Parser(Lexer lexer)
    {
        this.lexer = lexer;
    }

    public ParseTree Parse()
    {
    }

    private bool PerformAction(int actionId, /* TODO */ term)
    {
        if (actionId == 0)
        {
            // TODO: Accept
            return false;
        }
        if (actionId > 0)
        {
            this.stateStack.Push(actionId - 1);
            this.symbolStack.Push(term);
            return false;
        }
        actionId = -actionId - 1;
        switch (actionId)
        {
{{-for pair in reduce_action_ids}}
    {{-$prod = pair.key.production}}
        case {{pair.value}}:
        {
        {{-for i in 0..<array.size($prod.right)}}
            this.stateStack.Pop();
            var a{{i}} = this.symbolStack.Pop();
        {{-end}}
            var result = ConstructTree("{{$prod.left}}"
        {{-for i in 0..<array.size($prod.right)}}
            {{-}}, a{{i}}
        {{-end}}
        {{-}});
            break;
        }
{{-end}}
        default: Debug.Fail("Invalid action ID");
        }
        return true;
    }

    private static readonly ImmutableArray</*TODO*/> rowData = ImmutableArray.Create(
        {{$i = 0}}
{{-for state in uniq_states}}
        {{-if $i > 0}},
        {{end}}
    {{-action_row_starts[state.id] = $i}}
    {{-$j = 0}}
    {{-for pair in lr_rle_actions_row(table, state)}}
        {{-$elements = pair.item1}}
        {{-$repeat = pair.item2}}
        {{-if $j > 0}}, {{end}}
        {{-}}({{$j}}, ImmutableArray.Create(
        {{-$k = 0}}
        {{-for element in $elements}}
            {{-if $k++ > 0}}, {{end}}
            {{-if is_shift(element)}}
                {{-element.state.id + 1}}
            {{-else if is_reduce(element)}}
                {{-reduce_action_ids[element]}}
            {{-else}}
                {{-}}0
            {{-end}}
        {{-end-}}
        ))
        {{-$j += $repeat}}
        {{-$i += 1}}
    {{-end}}
{{-end}}
{{-$row_data_length = $i}}
    );

    private static readonly ImmutableArray<int> rowIndices = ImmutableArray.Create(
{{-$i = 0}}
{{-for state in table.states}}
    {{-if $i > 0}}, {{end}}
        {{-if $i++ % 16 == 0}}
        {{end}}
    {{-action_row_starts[dedup_states[state].id]}}
{{-end}},
        {{$row_data_length}}
    );

    private static readonly Comparer<(int, /* TODO */)> rowEntryComparer = Comparer<(int, /* TODO */)>.Create((a, b) => a.Item1 - b.Item1);

    private static /*TODO*/ LookupActions(int state, int termId)
    {
        var rowFirst = rowIndices[state];
        var rowCount = rowIndices[state + 1] - rowFirst;
        var index = rowData.BinarySearch(rowFirst, rowCount, (termId, /* TODO */), rowEntryComparer);
        if (index < 0) index = ~index;
        return rowData[index].Item2;
    }

    private static int LookupGoto(int state, int nontermId) => (state, nontermId) switch
    {
{{-for state in table.states}}
    {{-for nt in table.nonterminals}}
        {{-$to = lr_goto(table, state, nt)}}
        {{-if $to == null}} {{-continue}} {{-end}}
        ({{state.id}}, {{nonterm_ids[nt]}}) => {{$to.id}},
    {{-end}}
{{-end}}
        _ => throw new InvalidOperationException(),
    };
}
